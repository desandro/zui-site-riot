---

title: ZUI Site Riot
layout: article

---

ZUI Site Riot
=============

Before releasing the site for BeerCamp at SXSW 2011, I had never even heard of a ZUI. Back in the early planning stages

As it so happens, what the BeerCamp site accomplished was not an entirely new concept. 

Now with CSS3 transforms we have the delightful opportunity to experiment with innovative layouts and interfaces. While the paradigm of the vertical website will never fade away


---

Hear me, fellow developers! For too long have we been shackled in our one-dimensional prisons, bound to the tyranny of vertically-scrolling sites. How can we dare to "think outside the box" when we can barely conceive of a world that reaches beyond the fold of our closed realm?

But now is not the time for despair, as I have glimpsed the future. A revolution is at hand and its name is CSS Transforms.

---

As web developers, the concepts of design patterns and conventions have been beaten into our heads for a decade. But with every convention that we adhere to, we lose a chance to change the game and innovate our medium. With the BeerCamp at SXSW 2011 site, we at nclud recognized an ideal opportunity to try coloring outside the lines and try something new.

The vertically scrolling


---



With the BeerCamp site, we had an awesome opportunity to explore new possibilities of web design. As the majority of 

The reaction was incredible. Over 2,500 tweets about the site for its user interaction. People we not reacting to its message, or visual design, or the brand. They were excited about the way it worked.

Web developers

---

The typical reaction to BeerCamp was comprised of two sentiments "Wow" and "Neat, buts its a gimmick." Let me 

---


ZUI paradigm is well-suited for content that follows 


---

With the BeerCamp site, I chose to use a zoommable layout more as a spectacle and experiment than as a proper design convention. But that's not to say that zoomable interfaces have no merit. 

In the example, I am building a page that details the services of a web development shop. The services listed range from the broad - general web development - to the specific - CSS3 transforms. With each advancing section, the content dives deeper, more focused, and more technical. This content is well suited for a zoomable layout, as the subsequent sections are smaller segments of the previous sections.  Placing these sections inside one another visually communicate the relationship between them.

The basic content structure for this page is as follows:

Web development
  CMS Integration
  Server-side Scripting
  Front end development
    HTML
    JavaScript
    CSS
      Web Standards
      Higher performance
      CSS3
        Transitions
        Animation
        Transforms
          Scale
          Translate
          Rotation


## Basic layout

When laying out the sections of this page, we need to consider how each section will fit inside one another. I've chosen to use a ratio of 3:1 for the proportion between the current section and its subsequent section. The area of each section will be 900px x 540px so it fits within most browser windows. Subsequent sections will have dimensions one-third the full size, 300px x 180px.

The basic markup of the site so far:

    <div id="wrap">
      <div id="container">
        <ul id="nav">
          <li><a href="#web-dev">Web development</a></li>
          <li><a href="#front-end">Front-end development</a></li>
          <li><a href="#css">CSS</a></li>
          <li><a href="#css3">CSS3</a></li>
          <li><a href="#transforms">Transforms</a></li>
        </ul>
        <div id="content">
          <section id="web-dev">...</section>
          <section id="front-end">...</section>
          <section id="css">...</section>
          <section id="css3">...</section>
          <section id="transforms">...</section>
        </div> <!-- #content -->
      </div> <!-- #container -->
    </div> <!-- #wrap -->

The first draft of the site has the content laid out in the typical vertical pattern. This version is important to consider as this is what we can expect to provide to browsers that do not support CSS transforms or have JavaScript disabled. The rest of the effects will be built with progressive enhancement.  Users with less-capable browsers will still be able to consume the content.

You'll notice that each section has an empty space in the center of it.  This space has been reserved for the subsequent sections to fit inside it once CSS transforms are put in place.

## Adding transforms

With the basic layout established, we can now start adding CSS transforms. Before we jump in with the CSS, let's add Modernizr so we have more control over how browsers will inherit their styles.  I opted to use a custom build from the Modernizr 2.0 beta preview, that only tests for CSS 2D transforms and CSS transitions 
(http://modernizr.github.com/Modernizr/2.0-beta/#csstransforms-csstransitions-iepp). After adding the Modernizr code to scripts.js, we can target browsers that support transforms with `.csstransforms` in our CSS.

To scale each section inside one another, they first need to occupy the same space.  This can be done with absolute positioning.

    /* absolute positioning */
    .csstransforms #container { position: relative; }
    .csstransforms #content { position: absolute; }
    .csstransforms section { position: absolute; }

Each section needs to have its own scale set. As the proportion we are using is 3:1, each section's scale will be equal to three to the exponent of the section's zero-based index. The scale of first level, `#web-dev` is `1 / ( 3 ^ 0 )` or just 1, so we don't need to set that superfluous style.  The scale of the second level, `#front-end` is `1 / ( 3 ^ 1 )` or 1/3 or in decimal `0.3333`. The scale of the third level `#css` is  `1 / ( 3 ^ 2 )` or 1/9 or in decimal `0.1111`.  We'll apply this value to the various vendor-prefix `transform` CSS properties.

    /* level index 1 = 1 / ( 3 ^ 1 ) = 1/3 */
    .csstransforms #front-end {
      -webkit-transform: scale(0.3333);
         -moz-transform: scale(0.3333);
           -o-transform: scale(0.3333);
              transform: scale(0.3333);
    }
    
     /* level index 2 = 1 / ( 3 ^ 2 ) = 1/9 */
    .csstransforms #css {
      -webkit-transform: scale(0.1111);
         -moz-transform: scale(0.1111);
           -o-transform: scale(0.1111);
              transform: scale(0.1111);
    }
    
    /* level index 3 = 1 / ( 3 ^ 3 ) = 1/27 */
    .csstransforms #css3 {
      -webkit-transform: scale(0.037);
         -moz-transform: scale(0.037);
           -o-transform: scale(0.037);
              transform: scale(0.037);
    }
    
    /* level index 4 = 1 / ( 3 ^ 4 ) = 1/81 */
    .csstransforms #transforms {
      -webkit-transform: scale(0.0123456);
         -moz-transform: scale(0.0123456);
           -o-transform: scale(0.0123456);
              transform: scale(0.0123456);
    }

Awesome! The sections have been transformed to fit inside one another, like Russian nesting dolls. Now we need to build a mechanism to enable the user the zoom in.

To zoom in to a section, we only need to apply its reciprocal scale to the sections' parent `#content`. In mathmatically terms, the scale is equal to the level's zero-bas `#front-end` has a scale of 1/3, so it needs to be scaled 3x to bring it to 100% size.

    zoomScale = ratio ^ zero-based-level

The scale to view the third level would be 9 (3 ^ 2). For the fourth level, the scale would be 27 (3 ^ 3).

    /* view #css3, level index 3 = 3 ^ 3 = 27 */
    .csstransforms #content {
      -webkit-transform: scale(27);
         -moz-transform: scale(27);
           -o-transform: scale(27);
              transform: scale(27);
    }



## Scroll

Leveraging window scrolling is a natural convienent interaction to hook the zoom .  Along side clicking and pointing, scrolling is a natural interaction that users %%use%%.  But currently there might not be anything to scroll, since the entire page is self contained in that 900 x 540 portion. But we can fake it by adding an empty element that has height, which will serve as our proxy. The mark up will be added after `#wrap`.

    </div> <!-- #wrap -->
    <div id="scroller"></div>

In the CSS, set an arbitrary height on `#scroller`.  4000px works, as an approximate height of the page before we added the scale transforms

    .csstransforms #scroller { height: 4000px; }

But we don't want the content to scroll with the rest of the page, so we can use fixed positioning.

    /* prevent content from scrolling */
    #wrap { 
      position: fixed; 
      width: 100%;
    }

Now the page scrolls, but the content remains static. Our page is ready for scriptin'.

## JavaScript

The basic idea is that we are going to hijack the scroll event and do something with it. To help make our job easier, I'm using a constructor design pattern, the `Zoomer`, which will do all the work. It holds properties like `scrollY` which will be the scrolled vertical position. The `handleEvent` method binds `Zoomer.prototype.scroll` to the window's scroll event. This allows the constructor to be used within an event listener.  If a method matches the event's type, that method will be called.

    // only proceed if CSS transforms are supported
    if ( !Modernizr.csstransforms ) {
      return;
    }
    
    // the constructor that will do all the work
    function Zoomer() {
      this.scrolled = 0;
      // zero-based number of sections
      this.levels = 4;
    }
    
    // enables constructor to be used within event listener
    // like obj.addEventListener( eventName, this, false )
    Zoomer.prototype.handleEvent = function( event ) {
      if ( this[event.type] ) {
        this[event.type](event);
      }
    };
    
    // triggered every time window scrolls
    Zoomer.prototype.scroll = function( event ) {
      // scrollin' action
    };
    
    function init() {
      // init Zoomer constructor
      var ZUI = new Zoomer();
      // bind Zoomer to scroll event
      window.addEventListener( 'scroll', ZUI, false);
    }
    
    window.addEventListener( 'load', init, false );

`Zoomer.prototype.scroll` is where the magic will be happening. We first need to calculate the current position of the scroll relative the height of the page.

    Zoomer.prototype.scroll = function( event ) {
      // normalize scroll value from 0 to 1
      this.scrolled = window.pageYOffset / ( this.docHeight - window.innerHeight );
    };

We can take that `scrolled` value and use it for our scale value to zoom into the content.  We can use the same math we applied with the CSS above, except we are now using a percentage.  The percentage goes from 0 to 1, so we need to multiply it by the zero-based number of sections.

    zoomScale = ratio ^ ( percentage * levels )

This value can be applied as a CSS transform

    Zoomer.prototype.scroll = function( event ) {
      // normalize scroll value from 0 to 1
      this.scrolled = window.pageYOffset / ( this.docHeight - window.innerHeight );

      var scale = Math.pow( 3, this.scrolled * this.levels ),
          transformValue = 'scale('+scale+')';

      this.content.style.WebkitTransform = transformValue;
      this.content.style.MozTransform = transformValue;
      this.content.style.OTransform = transformValue;
      this.content.style.transform = transformValue;

    };

Now the content zooms when you scroll. Whooaaaaaaaaa.

## Navigation

Try clicking the page navigation.  Since implementing the transforms, we've broken it because there's nothing to scroll to -- all the content is held within itself.

To resolve this, we'll need to bind an event to the navigation, just like we did with the window scrolling.

Then we can use `Zoomer.prototype.click` to control what happens when a nav item is clicked. We can take the hash of the clicked element and pass it to another method `scrollFromHash`. With the hash, we can determine the level of its destination from the `levelGuide` set within the `Zoomer` constructor. This value then need to be interpolated as a distance in pixels from 0 to the scrollable height of the page.  Set here as `scrollY`.  We use this value to set the scroll position of the page.

Once we apply `scrollY` to `window.scrollTo`, the window scroll event is triggered, which in turn triggers Zoomer.scroll. The consequential transform is already take care for us.

    // triggered on nav click
    Zoomer.prototype.click = function( event ) {
      //  get scroll based on href of clicked nav item
      var hash = event.target.hash || event.target.parentNode.hash;
      this.scrollFromHash( hash );
      event.preventDefault();
    };
    
    // reverse engineer scroll position from hash
    Zoomer.prototype.scrollFromHash = function( hash ) {
      var targetLevel = this.levelGuide[ hash ];
      // proceed only if hash matches a level
      if ( targetLevel === undefined ) {
        return;
      }
      var scrollY = targetLevel / this.levels;
      // adjust for scrollable height
      scrollY = scrollY * ( this.docHeight - window.innerHeight );
      // set hash in location URL
      window.location.hash = hash;
      // set scroll position, Zoomer.scroll will take care of the rest
      window.scrollTo( 0, scrollY );
    };

Now when we click the navigation, the zoom is updated accordingly. We can also use the `scrollFromHash` method to zoom in if the page is loaded with a hash. Within `init()`:

    if ( window.location.hash ) {
      ZUI.scrollFromHash( window.location.hash );
    }

## Transitions

The navigation works again, but jumping from zoom to zoom is a bit disorienting. We can help the user understand what changed by add CSS transitions.  In the CSS, add the styles to enable CSS transitions.

    /* enables transitions */
    .csstransitions #content.transitions-enabled {
      -webkit-transition: -webkit-transform 1s;
         -moz-transition:    -moz-transform 1s;
           -o-transition:      -o-transform 1s;
              transition:         transform 1s;
    }

We cannot just add transitions, as they will interfere with the numerous transforms that get applied each time the window scrolls.  Instead, we'll want to enable transitions only when the navigation is clicked. Within `Zoomer.prototype.click` transitions can be enabled by adding the `transitions-enabled` class to `#content`.  As we need to disable the transition after the it has completed, we can add event listeners for the transition end event. The multiple event listeners are for different browsers.  `'webkitTransitionEnd'` for WebKit, `'oTransitionEnd'` for Opera, and `'transitionend'` for Firefox 4.

    if ( Modernizr.csstransitions ) {
      this.content.className = 'transitions-enabled';
      this.content.addEventListener( 'webkitTransitionEnd', this, false );
      this.content.addEventListener( 'oTransitionEnd', this, false );
      this.content.addEventListener( 'transitionend', this, false );
    }

Again, we're leveraging the `handleEvent` method to be able to pass in the constructor.  The respective methods only need to remove the `transitions-enabled` class and the event listeners.




    
    
    


  