---

title: ZUI Site Riot
layout: article

---

ZUI Site Riot
=============

Before releasing the site for BeerCamp at SXSW 2011, I had never even heard of a ZUI. Back in the early planning stages

As it so happens, what the BeerCamp site accomplished was not an entirely new concept. 

Now with CSS3 transforms we have the delightful opportunity to experiment with innovative layouts and interfaces. While the paradigm of the vertical website will never fade away


---

Hear me, fellow developers! For too long have we been shackled in our one-dimensional prisons, bound to the tyranny of vertically-scrolling sites. How can we dare to "think outside the box" when we can barely conceive of a world that reaches beyond the fold of our closed realm?

But now is not the time for despair, as I have glimpsed the future. A revolution is at hand and its name is CSS Transforms.

---

As web developers, the concepts of design patterns and conventions have been beaten into our heads for a decade. But with every convention that we adhere to, we lose a chance to change the game and innovate our medium. With the BeerCamp at SXSW 2011 site, we at nclud recognized an ideal opportunity to try coloring outside the lines and try something new.

The vertically scrolling


---



With the BeerCamp site, we had an awesome opportunity to explore new possibilities of web design. As the majority of 

The reaction was incredible. Over 2,500 tweets about the site for its user interaction. People we not reacting to its message, or visual design, or the brand. They were excited about the way it worked.

Web developers

---

The typical reaction to BeerCamp was comprised of two sentiments "Wow" and "Neat, buts its a gimmick." Let me 

---


ZUI paradigm is well-suited for content that follows 


---

With the BeerCamp site, I chose to use a zoommable layout more as a spectacle and experiment than as a proper design convention. But that's not to say that zoomable interfaces have no merit. 

In the example, I am building a page that details the services of a web development shop. The services listed range from the broad - general web development - to the specific - CSS3 transforms. With each advancing section, the content dives deeper, more focused, and more technical. This content is well suited for a zoomable layout, as the subsequent sections are smaller segments of the previous sections.  Placing these sections inside one another visually communicate the relationship between them.

The basic content structure for this page is as follows:

Web development
  CMS Integration
  Server-side Scripting
  Front end development
    HTML
    JavaScript
    CSS
      Web Standards
      Higher performance
      CSS3
        Transitions
        Animation
        Transforms
          Scale
          Translate
          Rotation


## Basic layout

When laying out the sections of this page, we need to consider how each section will fit inside one another. I've chosen to use a ratio of 3:1 for the proportion between the current section and its subsequent section. The area of each section will be 900px x 540px so it fits within most browser windows. Subsequent sections will have dimensions one-third the full size, 300px x 180px.

The basic markup of the site so far:

    <div id="wrap">
      <div id="container">
        <ul id="nav">
          <li><a href="#web-dev">Web development</a></li>
          <li><a href="#front-end">Front-end development</a></li>
          <li><a href="#css">CSS</a></li>
          <li><a href="#css3">CSS3</a></li>
          <li><a href="#transforms">Transforms</a></li>
        </ul>
        <div id="content">
          <section id="web-dev">...</section>
          <section id="front-end">...</section>
          <section id="css">...</section>
          <section id="css3">...</section>
          <section id="transforms">...</section>
        </div> <!-- #content -->
      </div> <!-- #container -->
    </div> <!-- #wrap -->

The first draft of the site has the content laid out in the typical vertical pattern. This version is important to consider as this is what we can expect to provide to browsers that do not support CSS transforms or have JavaScript disabled. The rest of the effects will be built with progressive enhancement.  Users with less-capable browsers will still be able to consume the content.

You'll notice that each section has an empty space in the center of it.  This space has been reserved for the subsequent sections to fit inside it once CSS transforms are put in place.

## Adding transforms

With the basic layout established, we can now start adding CSS transforms. Before we jump in with the CSS, let's add Modernizr so we have more control over how browsers will inherit their styles.  I opted to use a custom build from the Modernizr 2.0 beta preview, that only tests for CSS 2D transforms and CSS transitions 
(http://modernizr.github.com/Modernizr/2.0-beta/#csstransforms-csstransitions-iepp). After adding the Modernizr code to scripts.js, we can target browsers that support transforms with `.csstransforms` in our CSS.

To scale each section inside one another, they first need to occupy the same space.  This can be done with absolute positioning.

    /* absolute positioning */
    .csstransforms #container { position: relative; }
    .csstransforms #content { position: absolute; }
    .csstransforms section { position: absolute; }

Each section needs to have its own scale set. As the proportion we are using is 3:1, each section's scale will be equal to three to the exponent of the section's zero-based index. The scale of first level, `#web-dev` is `1 / ( 3 ^ 0 )` or just 1, so we don't need to set that superfluous style.  The scale of the second level, `#front-end` is `1 / ( 3 ^ 1 )` or 1/3 or in decimal `0.3333`. The scale of the third level `#css` is  `1 / ( 3 ^ 2 )` or 1/9 or in decimal `0.1111`.  We'll apply this value to the various vendor-prefix `transform` CSS properties.

    /* level index 1 = 1 / ( 3 ^ 1 ) = 1/3 */
    .csstransforms #front-end {
      -webkit-transform: scale(0.3333);
         -moz-transform: scale(0.3333);
           -o-transform: scale(0.3333);
              transform: scale(0.3333);
    }
    
     /* level index 2 = 1 / ( 3 ^ 2 ) = 1/9 */
    .csstransforms #css {
      -webkit-transform: scale(0.1111);
         -moz-transform: scale(0.1111);
           -o-transform: scale(0.1111);
              transform: scale(0.1111);
    }
    
    /* level index 2 = 1 / ( 3 ^ 3 ) = 1/27 */
    .csstransforms #css3 {
      -webkit-transform: scale(0.037);
         -moz-transform: scale(0.037);
           -o-transform: scale(0.037);
              transform: scale(0.037);
    }
    
    /* level index 2 = 1 / ( 3 ^ 4 ) = 1/81 */
    .csstransforms #transforms {
      -webkit-transform: scale(0.0123456);
         -moz-transform: scale(0.0123456);
           -o-transform: scale(0.0123456);
              transform: scale(0.0123456);
    }

Awesome! The sections have been transformed to fit inside one another, like Russian nesting dolls. Now we need to build a mechanism to enable the user the zoom in.

## Scroll

Leveraging window scrolling is a natural convienent interaction to hook the zoom .  Along side clicking and pointing, scrolling is a natural interaction that users %%use%%.  But currently there might not be anything to scroll, since the entire page is self contained in that 900 x 540 portion. But we can fake it by adding an empty element that has height, which will serve as our proxy. The mark up will be added after `#wrap`.

    </div> <!-- #wrap -->
    <div id="scroller"></div>

In the CSS, set an arbitrary height on `#scroller`.  4000px works, as an approximate height of the page before we added the scale transforms

    .csstransforms #scroller { height: 4000px; }

But we don't want the content to scroll with the rest of the page, so we can use fixed positioning.

    /* prevent content from scrolling */
    #wrap { 
      position: fixed; 
      width: 100%;
    }

Now the page scrolls, but the content remains static. Our page is ready for scriptin.

## JavaScript

The basic idea is that we are going to hijack the scroll event and do something with it. To help make our job easier, I'm using a constructor design pattern, the `Zoomer`, which will do all the work. It holds properties like `scrollY` which will be the scrolled vertical position. The `handleEvent` method binds `Zoomer.prototype.scroll` to the window's scroll event. This allows the constructor to be used within an event listener.  If a method matches the event's type, that method will be called.

    // only proceed if CSS transforms are supported
    if ( !Modernizr.csstransforms ) {
      return;
    }
    
    // the constructor that will do all the work
    function Zoomer() {
      this.scrollY = 0;
    }
    
    // enables constructor to be used within event listener
    // like obj.addEventListener( eventName, this, false )
    Zoomer.prototype.handleEvent = function( event ) {
      if ( this[event.type] ) {
        this[event.type](event);
      }
    };
    
    // triggered every time window scrolls
    Zoomer.prototype.scroll = function( event ) {
      // scrollin' action
    };
    
    function init() {
      // init Zoomer constructor
      var ZUI = new Zoomer();
      // bind Zoomer to scroll event
      window.addEventListener( 'scroll', ZUI, false);
    }
    
    window.addEventListener( 'load', init, false );

`Zoomer.prototype.scroll` is where the magic will be happening. We first need to calculate the current position of the scroll relative the height of the page.


